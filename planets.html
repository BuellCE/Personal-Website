<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
    <title>Evan Buell - Planet Project</title>
    <link rel="icon" href="assets/images/tab-icon.png">

    <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="bootstrap/css/bootstrap-extended.css">
    <link rel="stylesheet" href="Styles.css">
    <script src="bootstrap/js/jquery-3.3.1.slim.min.js"></script>
    <script src="bootstrap/js/popper.min.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
    <script src="Navbar.js"></script>
</head>

<body>

    <div id="header"></div>
    
    <div style="background-image: linear-gradient(to right, #DDD, #02d837); padding-top: 110px;">
        <div class="float-xl-middle p-4 text-right text-dark" style="max-width: 15in;">
            <h1 class="font-weight-bold text-light display-3 ml-2 pt-5">
                Project
            </h1>
            <h4 class="text-light display-5 m-2 pb-4">Procedural Planets<br>
        </div>
    </div>

    <div class="py-4 px-4 d-flex justify-content-center">
        <img class="d-block w-100 smooth-edges project-images" src="assets/images/Planets-Image.webp" style="max-width: 8in;" alt="Website Photo">
    </div>

    <div class="float-xl-middle text-dark flex-row d-flex justify-content-center pb-5">
        <div class="mx-3 double-text-spacing" style="max-width: 11in; font-size: 17px;">

            <div class="d-flex justify-content-center my-2">
                <p class="double-text-spacing text-center">
                    <a href="#Project-Overview">Project Overview</a>
                    <br>
                    <a href="#Generating-Planets">Generating Planets</a>
                    <br>
                    <a href="#Adding-Terrain">Adding Terrain</a>
                    <br>
                    <a href="#Applying-Movement">Applying Gravity and Movement</a>
                    <br>
                    <a href="#Conclusion">Conclusion</a>
                </p>
            </div>

            <h4 id="Project-Overview" class="text-center">
                Project Overview
            </h4>
            <p>
                In this project I wanted to generate planets with random terrain in a 3d space, and be able to move around them in a manner that is realistic. 
                For this to happen, I need to make several algorithms that are able to spawn in planets that consist of several meshes (chunks), 
                calculate the planet normals for gravity and movement, and seemlessly travel between planets.
            </p>
            <p>
                Since some of these algorithms can get complicated, I decided to make the project in the Unity Engine and write the scripts using C#. From my
                experience with Unity and Unreal Engines, I found the Unity Engine allowed for a quicker workflow over the Unreal Engine with C++, which is why 
                I chose it for this project.
            </p>
            <p>
                There are a lot of areas of programming involved in making this work, so instead of covering everything, I will only cover the areas that
                required the most attention.
            </p>

            <h4 id="Generating-Planets" class="text-center">
                Generating Planets
            </h4>
            <p>
                There are multiple ways I can think of to generate a planet, however each solution would have their pros and cons. One way that I considered was to
                generate a generic cube and use subdivision to divide each surface of the cube into more surfaces in order to add detail.
                The cube would be subdivided until it has the desired amount of detail, then I would normalize the distance of each point of the cube's surface
                with the center of the cube. This would essentially turn the cube into a sphere with enough vertices to start adding hills and mountains to our planets.
                The biggest problem with this approach though is not all surfaces of the planet will be equal. Below is an illustration of a cube that has been subdivided twice
                as the vertices are being normalized into a sphere-like shape.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/subdividedCube.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                It is clear that the surfaces where the corner of the cube existed are different than the rest of the surfaces. For this reason I took a different
                approach. By applying the same steps we did above but to a icosahedron (a polyhedron with 20 faces), our shape will more closely resemble a sphere. The main
                drawback to this approach is I would have to first generate a icosahedron, which isn't as simple as a cube. Below is an illustration of a icosahedron that has
                been subdivided three times with all vertices being normalized.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/icosahedronSubdivide.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                Visually it's a big improvement over the normalized cube. The biggest noticeable different however, is the shape of the surfaces are now triangles rather than
                quadrilaterals. While I made these shapes using Blender for testing, the shapes should turn out the same in Unity.
            </p>
            <p>
                Once we have our icosahedron, which can be imported as a 3d model (or created using code), we then need to subdivide it several times by adding a new vertex between 
                each two set of vertices. We do this by looping over every triangle in our planet, and adding a new vertex at the middle of each line. 
                Each triangle has 3 vertices and 3 lines, so we will make 3 new vertices for each triangle.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/triangles.jpg" style="max-width: 3in;" alt="Code snip">
            </div>
            <p>
                The above image shows the vertices of the original triangle in red. During the subdivision process we will create new vertices, shown as the blue circles, and join
                them together (represented by the green lines). This will turn our original one triangle into four. Below is the subdivision code that takes a list of triangles 
                (all triangles on our planet) and loops over them, subdividing each as represented above.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/subdivideMesh.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <h4 id="Adding-Terrain" class="text-center">
                Adding Terrain
            </h4>
            <p>
                The last thing the shape of our planet needs is some random terrain such as hills or mountains. There are several ways to do this, however the most obvious
                way is to add multiple layers of perlin noise (also called octaves). Perlin noise is a pseudo-random gradient of blacks and whites, and we can use this to represent
                the height of our planet at any given point. A point of pure black would mean no elevation gain on the planet, while a point of pure white by contrast
                means the elevation gain at that point is at a maximum. Since perlin noise consists of gradients, we will get smooth transitions between blacks and whites (low
                and high elevations) and our terrain should look smooth.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/noise.jpg" style="max-width: 3in;" alt="Code snip">
            </div>
            <p>
                The image above is an example of the noise we will use. Imagine it represents the height of our planet, we can take a sample point of the noise, get the gradient
                at that point as a value (black, white, or somewhere inbetween) and represent the value as a decimal between 0 and 1. We do this for several iterations
                until we have fully looped over every vertex on our planet. Below is an example of how we will take our sample points from the noise.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/noiseWithPoints.jpg" style="max-width: 3in;" alt="Code snip">
            </div>
            <p>
                If we apply several noises to our planet, but have the sample points change in spacing for each, we get what's called octaves. We do this to have more
                interesting terrain, and have the hills on our planet change in shape and size. Below is an example of two identical noises, but with different spacing between
                our sample points. The more sample points we take for a given space, the smoother the hills we get. The first image could represent mountains in our terrain,
                while the second could represent small hills.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/noiseWithPoints.jpg" style="max-width: 3in;" alt="Code snip">
                <img class="d-block w-100 smooth-edges ml-2" src="assets/images/noiseWithManyPoints.jpg" style="max-width: 3in;" alt="Code snip">
            </div>
            <p>
                While 2d noise would work well for adding elevation to a 2d plane, our planets are represented as 3d objects. Therefore, we will need to use 3d noise. The
                same principles apply, only now we are taking samples on all three dimensions, instead of just the two. We will add the perlin noise to our planets, and represent
                the octaves as C# classes that we can modify in the Unity editor. Below is the code used to add height to our vertices based on the octaves.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/perlinNoise.jpg" style="max-width: 7in;" alt="Code snip">
            </div>
            <p>
                The GetHeight method takes in the position of the vertex and returns a float to be used as a multiplier. The TerrainNoise3D class contains
                two variables, a height multiplier, and a noise spacing. Using these variables, the GetHeight method can now function like described in the perlin
                noise images above.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/perlinHeight.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                When we apply four octaves of varrying noise spacing and height multipliers, we get an object like the following:
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/firstPlanet.jpg" style="max-width: 4in;" alt="Code snip">
            </div>
            <p>
                While this works, it is important that we divide the planet up into several different objects, called chunks, to add performance benifits.
                For now I will take the faces of our initial icosahedron, and have each of those faces represent chunks. Our single planet would then be
                20 different smaller objects. If we wanted even larger planets with simular sized chunks, we could have our chunks use the faces of our icosahedron immediately after the
                first or second subdivision is applied. For now, our planet is fully generated and could easily be walked on by a character, which is the goal.
            </p>
            <h4 id="Applying-Movement" class="text-center">
                Applying Gravity and Movement
            </h4>
            <p>
                With default Unity mechanics, gravity is applied to all objects in the negative Y-axis direction, so we will be turning it off entirely. We need
                to get the direction of any given object to the center of the planet, and apply a force in that direction to that object. We know the position
                of the center of the planet, and we know the position of the object within the 3d space. Since positions are represented as 3 floating points (one for each axis),
                we can do some simple vector math to get the desired direction.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/planetDirection.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                We can multiply this value by a gravitational strength and apply that as a force to our objects. The value of strength can be determined
                by the distance an object is from the planet, and the mass of the planet which we can substitute for radius instead. Playing around with some
                values and the following code does exactly what we want.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/planetGravity.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                When the strength of the gravitational pull is too weak, we stop applying it altogether. This code will be called once every fixed update
                by the engine.
            </p>
            <p>
                Now that our character can fall towards the planet, the next step is to allow it to move around seemlessly. Since the character will move
                around in a first-person perspective, our "forwards", "backwards", "left", and "right" directions are based on where our character is looking.
                We can't move forwards by applying a force to the character in the same direction the character is looking, since the character would begin to fly
                if they looked straight upwards. My solution was to take the <b>cross product</b> between the planet's normal direction, and the right facing direction
                of the camera. The cross product is a vector that is orthogonal to
                two other vectors. Using this, the output would be our desired forwards direction.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/crossProduct.jpg" style="max-width: 3in;" alt="Code snip">
            </div>
            <p>
                For backwards movement we do the same thing as forwards but with the left-facing direction of the camera. For left and right movement we take the 
                forwards/backwards facing directions of the camera instead of the right/left directions
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/planetMovement.jpg" style="max-width: 8in;" alt="Code snip">
            </div>
            <p>
                This does assume that our character is standing upright on the planet however. If we take the upwards direction of our character, and the planet's normal
                direction, we can keep our character's rotation upright. Unity uses Quaternions to represent rotations since they are gimbal-lock free and can be modified
                easily. Therefore we will need to translate the two 3-dimensional vectors into a Quaternion. The FromToRotation method creates a Quaternion based on the
                "from direction" as it rotates towards the "to direction", which is exactly what we need.
            </p>
            <div class="d-flex justify-content-center my-2">
                <img class="d-block w-100 smooth-edges" src="assets/images/codeSnips/planetForceAngle.jpg" style="max-width:7in;" alt="Code snip">
            </div>
            <p>
                The transform.rotation is our characters rotation. We execute this code once every fixed update by the engine, and our character
                will remain upright on the planet. We can now move around freely, perfect!
            </p>
            <h4 id="Conclusion" class="text-center">
                Conclusion
            </h4>
            <p>
                While I didn't cover every topic of this project, I touched base on the most complicated aspects. A lot of the code should be straight forwards to
                someone who has used an engine like Unity before. I added some simple visual elements to the project, along with some simple extra movements such as a
                jetpack. All of the project's c# scripts can be found on github
                <a href="#">here</a>. A video demo of the project can be found below. Thanks for reading.
            </p>
        </div>
    </div>

    <div id="footer"></div>

</body>
</html>